name: 'Terraform Azure Infrastructure'

on:
  # Ejecuta autom√°ticamente en cada push a main (despliega)
  push:
    branches:
      - main
  # Valida en Pull Requests (no despliega)
  pull_request:
    branches:
      - main
  # Despliegue manual desde GitHub UI
  workflow_dispatch:
    inputs:
      action:
        description: 'Terraform action to perform'
        required: true
        default: 'plan'
        type: choice
        options:
          - plan
          - apply
          - destroy
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - prod

env:
  TF_VERSION: '1.6.0'
  WORKING_DIR: '.'

jobs:
  terraform:
    name: 'Terraform ${{ github.event.inputs.action || ''plan'' }}'
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'dev' }}
    
    defaults:
      run:
        shell: bash
        working-directory: ${{ env.WORKING_DIR }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Setup Terraform Backend
      run: |
        echo "üîß Setting up Terraform backend storage..."
        
        STORAGE_ACCOUNT_NAME="tfstateimtronick2025"
        
        # Create resource group for Terraform state (idempotent)
        echo "Creating resource group terraform-state-rg..."
        az group create --name terraform-state-rg --location eastus --output table || true
        
        # Create storage account for Terraform state (idempotent)
        echo "Creating storage account $STORAGE_ACCOUNT_NAME..."
        az storage account create \
          --name "$STORAGE_ACCOUNT_NAME" \
          --resource-group terraform-state-rg \
          --location eastus \
          --sku Standard_LRS \
          --encryption-services blob \
          --allow-blob-public-access false \
          --output table || echo "Storage account already exists, continuing..."
        
        # Wait for storage account to be ready
        echo "Waiting for storage account to be ready..."
        sleep 5
        
        # Get storage account key
        ACCOUNT_KEY=$(az storage account keys list \
          --resource-group terraform-state-rg \
          --account-name "$STORAGE_ACCOUNT_NAME" \
          --query '[0].value' -o tsv)
        
        # Create container for Terraform state (idempotent)
        echo "Creating container tfstate..."
        az storage container create \
          --name tfstate \
          --account-name "$STORAGE_ACCOUNT_NAME" \
          --account-key "$ACCOUNT_KEY" \
          --output table || echo "Container already exists, continuing..."
        
        echo "‚úÖ Terraform backend storage configured successfully!"
        echo "Storage Account: $STORAGE_ACCOUNT_NAME"
    
    - name: Terraform Format Check
      id: fmt
      run: terraform fmt -check
      continue-on-error: true
    
    - name: Terraform Init
      id: init
      run: terraform init -backend-config="key=${{ github.event.inputs.environment || 'dev' }}.terraform.tfstate"
      env:
        ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
        ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
        ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
        ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
    
    - name: Terraform Validate
      id: validate
      run: terraform validate -no-color
    
    - name: Select tfvars file
      id: tfvars
      run: |
        if [ "${{ github.event.inputs.environment }}" == "prod" ]; then
          echo "file=prod.tfvars" >> $GITHUB_OUTPUT
        else
          echo "file=dev.tfvars" >> $GITHUB_OUTPUT
        fi
    
    - name: Terraform Plan
      id: plan
      if: github.event_name == 'pull_request' || github.event.inputs.action == 'plan' || github.event_name == 'push'
      run: terraform plan -var-file="${{ steps.tfvars.outputs.file }}" -no-color -input=false -out=tfplan
      continue-on-error: true
      env:
        ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
        ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
        ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
        ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
    
    - name: Update Pull Request
      uses: actions/github-script@v7
      if: github.event_name == 'pull_request'
      env:
        PLAN: "terraform\n${{ steps.plan.outputs.stdout }}"
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const output = `#### Terraform Format and Style üñå\`${{ steps.fmt.outcome }}\`
          #### Terraform Initialization ‚öôÔ∏è\`${{ steps.init.outcome }}\`
          #### Terraform Validation ü§ñ\`${{ steps.validate.outcome }}\`
          #### Terraform Plan üìñ\`${{ steps.plan.outcome }}\`
          
          <details><summary>Show Plan</summary>
          
          \`\`\`\n
          ${process.env.PLAN}
          \`\`\`
          
          </details>
          
          *Pushed by: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: output
          })
    
    - name: Terraform Plan Status
      if: steps.plan.outcome == 'failure'
      run: exit 1
    - name: Import existing resources (if not in state)
      if: github.event.inputs.action == 'apply' || (github.event_name == 'push' && github.ref == 'refs/heads/main')
      run: |
        echo "INFO Checking for existing resources not in Terraform state..."
        
        # Resolve resource group name from the selected tfvars file
        RG_NAME=$(grep -E '^[[:space:]]*resource_group_name[[:space:]]*=' "${{ steps.tfvars.outputs.file }}" | head -n1 | awk -F= '{print $2}' | tr -d ' "')
        if [ -z "$RG_NAME" ]; then
          echo "INFO resource_group_name not found in ${{ steps.tfvars.outputs.file }}"
          exit 1
        fi
        
        # Check if resource group exists in Azure
        if az group exists --name "$RG_NAME" | grep -q "true"; then
          echo "INFO Resource group $RG_NAME exists in Azure"
          
          # Check if it's in Terraform state
          if ! terraform state show azurerm_resource_group.main > /dev/null 2>&1; then
            echo "INFO Resource group NOT in Terraform state, importing..."
            terraform import -var-file="${{ steps.tfvars.outputs.file }}" \
              azurerm_resource_group.main \
              /subscriptions/${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}/resourceGroups/$RG_NAME
            echo "INFO Resource group imported successfully"
          else
            echo "INFO Resource group already in Terraform state, skipping import"
          fi
        else
          echo "INFO No existing resource group found in Azure"
        fi
      continue-on-error: true
      env:
        ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
        ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
        ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
        ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
    
    - name: Terraform Apply
      if: github.event.inputs.action == 'apply' || (github.event_name == 'push' && github.ref == 'refs/heads/main')
      run: terraform apply -var-file="${{ steps.tfvars.outputs.file }}" -auto-approve -input=false
      env:
        ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
        ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
        ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
        ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
    
    - name: Terraform Destroy
      if: github.event.inputs.action == 'destroy'
      run: terraform destroy -var-file="${{ steps.tfvars.outputs.file }}" -auto-approve -input=false
      env:
        ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
        ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
        ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
        ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
    
    - name: Terraform Output
      if: github.event.inputs.action == 'apply' || (github.event_name == 'push' && github.ref == 'refs/heads/main')
      run: terraform output
